![编译流程](./assets/2_1.png)
## 预编译
- 预编译流程
    - 将所有 “#define” 删除，展开所有宏定义
    - 处理所有条件预编译指令(#if,#elif等)
    - 处理 #include 预编译指令，将包含的文件插入对应位置
    - 删除所有注释
    - 添加行号和文件标识名
    - 保留所有#pragma编译器指令
## 编译
把预处理完的文件进行词法分析，语法分析，语义分析和相关优化操作，产生对应的汇编代码文件
## 汇编
汇编器将汇编代码转化为机器码
# 编译过程
6步，扫描，语法分析，语义分析，源代码优化，代码生成，目标代码优化
![编译流程](./assets/2_2.png)
代码例子：
```cpp
array[index] = (index+4)*(2+6);
```
## 词法分析
把源代码程序输入到扫描器(有限状态机)，分割成一个个记号(Token),比如上面的代码例子通过扫描器后，会生成对应的token表：
![编译流程](./assets/2_3.png)
## 语法分析
用上下文无关语法的手段对扫描器产生的记号进行语法分析，产生语法树（表达式为节点的数）。
![语法树](./assets/2_4.png)
整个语句是一个赋值表达式，左子树是一个数组表达式，右子树是一个乘法表达式，再一次递归直到到达符号和数字(符号和数字是最小的表达式，一般作为语法树的叶子节点)。其中各个符号的优先级已经手动确定，有歧义的符号也有相应的意义确定。
## 语义分析
语法分析仅仅是完成了对表达式语法层面的分析，并不了解这个语句是否真正有意义。(比如两个指针乘法运算，语法上合法，但是是没有意义的)。编译器能分析的语义是**静态语义**，在运行期才能确定的语义叫**动态语义**。
- 静态语义包括生命和类型的匹配，比如float变量赋值给int变量会有一个类型转换的过程，将浮点型赋值给指针语义分析程序就会发现类型不匹配，报错。比如0作为除数就是一个运行期语义错误。
- 语义分析会在语法树上的表达式标识类型
![语义分析](./assets/2_5.png)
## 中间语言生成
将整个语法树转换为中间代码(语法树的顺序表示)。中间代码常用的形式有**三地址码**，**P-代码**，比如三地址码，我们把上面的语法树翻译成三地址码后，就是
```cpp
t1 = 2 + 6
t2 = index + 4
t3 = t1 * t2
array[index] = t3
```
还可以进一步优化：
```cpp
t2 = index + 4
t2 = t2* 8
array[index] = t2
```

## 目标代码生成与优化
在这里代码生成器将上面的中间代码转换成目标机器码，最后目标代码优化器对目标代码进行优化(选择合适的寻址方式，用位移代替乘法，删除多余指令等)。
## 链接
一个程序被分割成多个模块，要解决各个模块间如何通信的问题，C/C++模块间通信的方式两种，一是模块间的函数调用，二是模块间的变量访问，本质就是模块间符号的引用，而这个引用/组装的过程就是链接
## 静态链接
链接的工作就是把一些指令对其他符号地址的引用加以修正(重定向).链接的过程主要有：
- 地址和空间分配
- 符号决议（符号绑定）
- 重定向（之前编译时不知道的其他模块的变量/函数调用地址被赋值为0，静态链接时给每个这样的绝对地址引用打补丁，让他们指向正确的地址）
静态链接过程：
![静态链接过程](./assets/2_6.png)
