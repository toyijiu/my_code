本节的目标是将两个.c文件静态链接并学习其中的链接过程
```cpp
//a.c
extern int shared;

int main()
{
    int a = 100;
    swap(&a,&shared);
}
```
```cpp
//b.c
int shared = 1;

void swap(int* a,int* b)
{
    *a^=*b^=*a^=*b;
}
```
## 空间和地址分配
多个目标文件静态链接时各个文件的段空间是怎么分配的
### 按序叠加
![按序叠加](./assets/4_1.png)
缺点是目标文件较多时链接后的段空间个数太多了，浪费空间（每个段要对齐等）
### 相似段合并
![相似合并](./assets/4_2.png)
.bss段在装载时要占用地址空间，在目标文件和可执行文件不占用空间。bss段分配空间的意义只局限于虚拟地址分配的空间，在实际物理存储中没有，因为他并没有内容。我们说的。bss占据空间指的是虚拟地址空间。
链接器一般采用这种方法。步骤一般有两步：
- 空间和地址分配：扫描各个目标文件段的长度，属性，位置，合并符号表的所有符号到全局符号表，链接器也会获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，建立映射关系。
- 符号解析与重定位：读取输入文件中段的数据，重定位信息，并且进行符号解析与重定位，调整代码中的地址等。这一步是链接的核心，尤其是重定位过程。

链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址，即各个段中的VMA(虚拟内存地址)和size，链接前目标文件中的所有段的VMA都是0，因为此时虚拟空间还没有被分配，所以它们默认都是0.链接后可执行文件中的各个段都被分配到了相应的虚拟地址。如下图：
![链接前后内存分配](./assets/4_3.png)

### 符号地址的确定
在前一步完成后，链接器开始计算各个符号的虚拟地址。因为各个符号在段内的相对位置是固定的，所以这时候main，shared，swap的地址已经是确定的了，只是链接器需要给每个符号一个偏移量，使它们能够调整到正确的虚拟地址。然后通过对应段的基地址+偏移量，得出符号的实际的虚拟地址，更新全局符号表。

### 符号的重定位
编译生成的目标文件中对于找不到定义的符号暂时用其他值代替。链接的时候就需要重定位了。
问题是链接器怎么知道哪些指令需要调整，这些指令的哪些部分需要调整？就是之前编译的时候各个目标文件保存的重定位表。
每一个需要被重定位的ELF段都有一个对应的重定位表，如果text段有需要重定位的地方，那它就会保存一个重定位表，可以通过objdump来查看目标文件的重定位表：
![重定位表](./assets/4_4.png)
显示了a.o所有引用到外部符号的地址，OFFSET偏移表示该重定位符号在段中的偏移地址，上面的.text表示这个是text段的重定位表，
![重定位表结构](./assets/4_5.png)

### 符号解析
链接的主要目的就是引用的外部符号的重定位。日常开发链接遇到的最大问题也是这个，链接时符号未定义。
当链接器去重定位符号表中的符号时，会去查询链接时生成的全局符号表，找到对应符号后进行重定位。一下是目标文件中的符号表：
![目标文件中的符号表](./assets/4_6.png)

### 指令修正方式
